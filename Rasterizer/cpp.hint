// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define VM_VEC_OP(vec_type, S, DT) vec_type operator +(const vec_type& b) const { vec_type ret{}; for (size_t i = 0; i < S; i++) ret[i] = this->data[i] + b.data[i]; return ret; } vec_type operator -(const vec_type& b) const { vec_type ret{}; for (size_t i = 0; i < S; i++) ret[i] = this->data[i] - b.data[i]; return ret; } vec_type operator *(const vec_type& b) const { vec_type ret{}; for (size_t i = 0; i < S; i++) ret[i] = this->data[i] * b.data[i]; return ret; } vec_type operator *(DT b) const { vec_type ret{}; for (size_t i = 0; i < S; i++) ret[i] = this->data[i] * b; return ret; } vec_type operator /(DT b) const { vec_type ret{}; for (size_t i = 0; i < S; i++) ret[i] = this->data[i] / b; return ret; } DT dot(const vec_type& b) const { DT ret = DT(0); for (size_t i = 0; i < S; i++) ret += this->data[i] * b.data[i]; return ret; } vec_type normalized() const { float inv_len = 1.0f / float(this->length()); vec_type self = (*this); return self * DT(inv_len); } vec_type lerp(const vec_type& b, float t) const { vec_type ret{}; for (size_t i = 0; i < S; i++) ret[i] = (1.0f - t) * this->data[i] + b.data[i] * t; return ret; } friend vec_type operator /(const DT scalar, const vec_type& b) const { vec_type ret{}; for (size_t i = 0; i < S; i++) ret[i] = scalar / b[i]; return ret; }
